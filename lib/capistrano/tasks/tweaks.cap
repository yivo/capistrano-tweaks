def result_of(proc)
  proc.is_a?(Proc) ? proc.call : proc
end

def run_interactively(command, server)
  exec %Q(ssh #{server.user}@#{server.hostname} -t '#{command}')
end

def config_define_tasks(options = {})
  desc "#{cmd.to_s.capitalize} config"
  task :install do
    on roles(result_of(options[:roles])) do |role|
      name     = File.basename(result_of(options[:template_path]), '*.erb')
      dir      = File.dirname(result_of(options[:template_path]))
      template = config_resolve_template(name, dir: dir, role: role)
      config   = config_render_template(template, role: role)
      config_install_remotely(config, result_of(options[:install_path]))
    end
  end

  desc 'Uninstall config'
  task :uninstall do
    on roles(result_of(options[:roles]))
      config_uninstall_remotely(result_of(options[:install_path]))
  end
end

def config_install_remotely(config, config_path)
  config_backup_remotely(config_path)

  config_name     = File.basename(config_path)
  config_tmp_path = "#{fetch(:tmp_dir)}/#{config_name}"
  stream          = StringIO.new(config)

  upload!(stream, config_tmp_path)

  sudo "mkdir -p #{File.dirname(config_path)}"
  sudo "mv #{config_tmp_path} #{config_path}"
end

def config_uninstall_remotely(config_path)
  config_path = result_of(config_path)
  config_backup_remotely(config_path)
  sudo "rm -f #{config_path}"
end

def config_backup_remotely(config_path)
  config_exists = test("[ -f #{config_path} ]")
  sudo "cp #{config_path} #{config_path}.bak" if config_exists
end

def config_resolve_template(name, options = {})
  basename    = File.basename(name, '.*')
  dot_ext     = File.extname(name).sub(/\A\.+/, '.')

  role        = options[:role]
  hostname    = options[:hostname]
  hostname    = (role.properties.name || role.hostname) if role && hostname.nil?

  stage       = options[:stage]
  stage       = fetch(:stage) if stage.nil?

  tmpl_dirs   = ['config', [options[:dir]]].flatten.reject(&:nil?)
  tmpl_exts   = ['.erb', '']
  tmpl_names  = %W(
    #{basename}_#{hostname}_#{stage}#{dot_ext}
    #{basename}_#{hostname}#{dot_ext}
    #{basename}_#{stage}#{dot_ext}
    #{basename}#{dot_ext}
  )

  tmpl_dirs.each do |tdir|
    tmpl_names.each do |tname|
      tmpl_exts.each do |text|
        tpath = "#{tdir}/#{tname}#{text}"
        if File.file?(tpath)
          info "Resolved config template '#{tpath}'"
          return File.read(tpath)
        end
      end
    end
  end

  error "Config template '#{name}' could not be resolved!"
end

def config_render_template(template, options = {})
  @role = options[:role]
  ERB.new(template).result(binding)
end

def daemon_define_control_tasks(options = {})
  [:start, :stop, :restart, :status].each do |cmd|
    desc "#{cmd.capitalize} #{options[:service]} service"
    task cmd do
      on roles(result_of(options[:roles])) do
        sudo "/usr/bin/service #{options[:service]}"
      end
    end
  end
end