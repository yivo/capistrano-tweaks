def result_of(proc)
  proc.is_a?(Proc) ? proc.call : proc
end

def run_interactively(command, server)
  exec %Q(ssh #{server.user}@#{server.hostname} -t '#{command}')
end

def config_define_install_tasks(options = {})
  desc 'Install config'
  task :install do
    on roles(result_of(options[:roles])) do |role|
      config_name = result_of(options[:config_name])
      template    = config_resolve_template(config_name,
        dir:  result_of(options[:config_dir]),
        role: role
      )
      config      = config_render_template(template, role: role)
      config_install_remotely(config, options.merge(role: role))
    end
  end
end

def config_install_remotely(config, options = {})
  to   = result_of(options[:install_to]) || result_of(options[:to])
  as   = result_of(options[:install_as]) || result_of(options[:as])
  name = result_of(options[:install_name]) || result_of(options[:name])
  dir  = result_of(options[:install_dir]) || result_of(options[:dir])

  config_path     = to || as
  config_path   ||= File.join(dir, name)
  config_name     = File.basename(config_path)
  config_tmp_path = "#{fetch(:tmp_dir)}/#{config_name}"
  config_backup_remotely(config_path) if options[:backup] != false
  stream = StringIO.new(config)
  upload!(stream, config_tmp_path)
  sudo "mkdir -p #{File.dirname(config_path)}"
  sudo "mv #{config_tmp_path} #{config_path}"
end

def config_resolve_template(config_name, options = {})
  basename    = File.basename(config_name, '.*')
  dot_ext     = File.extname(config_name).sub(/\A\.+/, '.')

  role        = options[:role]
  hostname    = options[:hostname]
  hostname    = (role.properties.name || role.hostname) if role && hostname.nil?

  stage       = options[:stage]
  stage       = fetch(:stage) if stage.nil?

  tmpl_dirs   = ['config', options[:dir]].reject(&:nil?)
  tmpl_exts   = ['.erb', '']
  tmpl_names  = %W(
    #{basename}_#{hostname}_#{stage}#{dot_ext}
    #{basename}_#{hostname}#{dot_ext}
    #{basename}_#{stage}#{dot_ext}
    #{basename}#{dot_ext}
  )

  tmpl_dirs.each do |dir|
    tmpl_names.each do |name|
      tmpl_exts.each do |ext|
        path = "#{dir}/#{name}#{ext}"
        if File.file?(path)
          info "Resolved config template '#{path}'"
          return File.read(path)
        end
      end
    end
  end

  error "Config template '#{config_name}' could not be resolved!"
end

def config_render_template(template, options = {})
  @role = options[:role]
  ERB.new(template).result(binding)
end

def config_backup_remotely(config_path)
  config_exists = test("[ -f #{config_path} ]")
  sudo "cp #{config_path} #{config_path}.bak" if config_exists
end